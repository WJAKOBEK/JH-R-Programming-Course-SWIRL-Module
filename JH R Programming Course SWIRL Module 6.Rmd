

The first element of num_vect is 0.5, which is less than 1 and therefore the statement 0.5 < 1 is TRUE. The second
| element of num_vect is 55, which is greater than 1, so the statement 55 < 1 is FALSE. The same logic applies for the
| third and fourth elements.

...

  |=============================                                                                                |  26%
| Let's try another. Type num_vect >= 6 without assigning the result to a new variable.

> num_vect >= 6
[1] FALSE  TRUE FALSE  TRUE

| You got it!

  |================================                                                                             |  29%
| This time, we are asking whether each individual element of num_vect is greater than OR equal to 6. Since only 55
| and 6 are greater than or equal to 6, the second and fourth elements of the result are TRUE and the first and third
| elements are FALSE.

...

  |==================================                                                                           |  32%
| The `<` and `>=` symbols in these examples are called 'logical operators'. Other logical operators include `>`,
| `<=`, `==` for exact equality, and `!=` for inequality.

...

  |=====================================                                                                        |  34%
| If we have two logical expressions, A and B, we can ask whether at least one is TRUE with A | B (logical 'or' a.k.a.
| 'union') or whether they are both TRUE with A & B (logical 'and' a.k.a. 'intersection'). Lastly, !A is the negation
| of A and is TRUE when A is FALSE and vice versa.

...

  |========================================                                                                     |  37%
| It's a good idea to spend some time playing around with various combinations of these logical operators until you
| get comfortable with their use. We'll do a few examples here to get you started.

...

  |===========================================                                                                  |  39%
| Try your best to predict the result of each of the following statements. You can use pencil and paper to work them
| out if it's helpful. If you get stuck, just guess and you've got a 50% chance of getting the right answer!

...

  |==============================================                                                               |  42%
| (3 > 5) & (4 == 4)

1: TRUE
2: FALSE

Selection: 2

| Keep working like that and you'll get there!

  |=================================================                                                            |  45%
| (TRUE == TRUE) | (TRUE == FALSE)

1: TRUE
2: FALSE

Selection: 1

| Keep up the great work!

  |====================================================                                                         |  47%
| ((111 >= 111) | !(TRUE)) & ((4 + 1) == 5)

1: TRUE
2: FALSE

Selection: 2

| You almost had it, but not quite. Try again.

| This is a tricky one. Remember that the `!` symbol negates whatever comes after it. There's also an 'order of
| operations' going on here. Conditions that are enclosed within parentheses should be evaluated first. Then, work
| your way outwards.

1: FALSE
2: TRUE

Selection: 1

| You're close...I can feel it! Try it again.

| This is a tricky one. Remember that the `!` symbol negates whatever comes after it. There's also an 'order of
| operations' going on here. Conditions that are enclosed within parentheses should be evaluated first. Then, work
| your way outwards.

1: FALSE
2: TRUE

Selection: 1

| Keep trying!

| This is a tricky one. Remember that the `!` symbol negates whatever comes after it. There's also an 'order of
| operations' going on here. Conditions that are enclosed within parentheses should be evaluated first. Then, work
| your way outwards.

1: FALSE
2: TRUE

Selection: 2

| Keep working like that and you'll get there!

  |======================================================                                                       |  50%
| Don't worry if you found these to be tricky. They're supposed to be. Working with logical statements in R takes
| practice, but your efforts will be rewarded in future lessons (e.g. subsetting and control structures).

...

  |=========================================================                                                    |  53%
| Character vectors are also very common in R. Double quotes are used to distinguish character objects, as in the
| following example.

...

  |============================================================                                                 |  55%
| Create a character vector that contains the following words: "My", "name", "is". Remember to enclose each word in
| its own set of double quotes, so that R knows they are character strings. Store the vector in a variable called
| my_char.

> 
> my_char <- vector(""My"", ""name"", ""is"")
Error: unexpected symbol in "my_char <- vector(""My"
> my_char <- c(""My"", ""name"", ""is"")
Error: unexpected symbol in "my_char <- c(""My"
> my_char <- c("My", "name", "is")

| You are quite good my friend!

  |===============================================================                                              |  58%
| Print the contents of my_char to see what it looks like.

> my_char
[1] "My"   "name" "is"  

| Perseverance, that's the answer.

  |==================================================================                                           |  61%
| Right now, my_char is a character vector of length 3. Let's say we want to join the elements of my_char together
| into one continuous character string (i.e. a character vector of length 1). We can do this using the paste()
| function.

...

  |=====================================================================                                        |  63%
| Type paste(my_char, collapse = " ") now. Make sure there's a space between the double quotes in the `collapse`
| argument. You'll see why in a second.

> paste(my_char, collapse = " ")
[1] "My name is"

| That's a job well done!

  |========================================================================                                     |  66%
| The `collapse` argument to the paste() function tells R that when we join together the elements of the my_char
| character vector, we'd like to separate them with single spaces.

...

  |===========================================================================                                  |  68%
| It seems that we're missing something.... Ah, yes! Your name!

...

  |=============================================================================                                |  71%
| To add (or 'concatenate') your name to the end of my_char, use the c() function like this: c(my_char,
| "your_name_here"). Place your name in double quotes where I've put "your_name_here". Try it now, storing the result
| in a new variable called my_name.

> my_name <- c(my_char,"WZJ")

| You are amazing!

  |================================================================================                             |  74%
| Take a look at the contents of my_name.

> my_name
[1] "My"   "name" "is"   "WZJ" 

| That's a job well done!

  |===================================================================================                          |  76%
| Now, use the paste() function once more to join the words in my_name together into a single character string. Don't
| forget to say collapse = " "!

> paste("my_name")
[1] "my_name"

| Not exactly. Give it another go. Or, type info() for more options.

| Use paste(my_name, collapse = " ") to join all four words together, separated by single spaces.

> Use paste(my_name, collapse = " ")
Error: unexpected symbol in "Use paste"
> Use paste(my_name, collapse = ""My"   "name" "is"   "WZJ" ")
Error: unexpected symbol in "Use paste"
> paste(my_name, collapse = ""My"   "name" "is"   "WZJ" ")
Error: unexpected symbol in "paste(my_name, collapse = ""My"
> paste(my_name, collapse = "My"   "name" "is"   "WZJ")
Error: unexpected string constant in "paste(my_name, collapse = "My"   "name""
> paste(my_name, collapse =""! "My"   "name" "is"   "WZJ")
Error: unexpected '!' in "paste(my_name, collapse =""!"
> paste(my_name, collapse = " " My name is WZJ)
Error: unexpected symbol in "paste(my_name, collapse = " " My"
> ?collapse
> collapse(ny_name, sep = "", My = , last = "")
Error in collapse(ny_name, sep = "", My = , last = "") : 
  could not find function "collapse"
> paste(my_name, collapse = " ")
[1] "My name is WZJ"

| Nice work!

  |======================================================================================                       |  79%
| In this example, we used the paste() function to collapse the elements of a single character vector. paste() can
| also be used to join the elements of multiple character vectors.

...

  |=========================================================================================                    |  82%
| In the simplest case, we can join two character vectors that are each of length 1 (i.e. join two words). Try
| paste("Hello", "world!", sep = " "), where the `sep` argument tells R that we want to separate the joined elements
| with a single space.

> paste("Hello", "world!", sep = " ")
[1] "Hello world!"

| All that hard work is paying off!

  |============================================================================================                 |  84%
| For a slightly more complicated example, we can join two vectors, each of length 3. Use paste() to join the integer
| vector 1:3 with the character vector c("X", "Y", "Z"). This time, use sep = "" to leave no space between the joined
| elements.

> c("x","y", "v")
[1] "x" "y" "v"

| That's not the answer I was looking for, but try again. Or, type info() for more options.

| Use paste(1:3, c("X", "Y", "Z"), sep = "") to see what happens when we join two vectors of equal length using
| paste().

> paste(1:3, c("X", "Y", "Z"), sep = "")
[1] "1X" "2Y" "3Z"

| All that practice is paying off!

  |===============================================================================================              |  87%
| What do you think will happen if our vectors are of different length? (Hint: we talked about this in a previous
| lesson.)

...

  |==================================================================================================           |  89%
| Vector recycling! Try paste(LETTERS, 1:4, sep = "-"), where LETTERS is a predefined variable in R containing a
| character vector of all 26 letters in the English alphabet.

> paste(LETTERS, 1:4, sep = "-")
 [1] "A-1" "B-2" "C-3" "D-4" "E-1" "F-2" "G-3" "H-4" "I-1" "J-2" "K-3" "L-4" "M-1" "N-2" "O-3" "P-4" "Q-1" "R-2" "S-3"
[20] "T-4" "U-1" "V-2" "W-3" "X-4" "Y-1" "Z-2"

| Great job!

  |====================================================================================================         |  92%
| Since the character vector LETTERS is longer than the numeric vector 1:4, R simply recycles, or repeats, 1:4 until
| it matches the length of LETTERS.

...

  |=======================================================================================================      |  95%
| Also worth noting is that the numeric vector 1:4 gets 'coerced' into a character vector by the paste() function.

...

  |==========================================================================================================   |  97%
| We'll discuss coercion in another lesson, but all it really means is that the numbers 1, 2, 3, and 4 in the output
| above are no longer numbers to R, but rather characters "1", "2", "3", and "4".

...

  |=============================================================================================================| 100%
| Would you like to inform someone about your successful completion of this lesson via email?

1: Yes
2: No

Selection: 2

| Keep up the great work!

| You've reached the end of this lesson! Returning to the main menu...

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: R Programming E
3: Take me to the swirl course repository!

Selection: 2

| Please choose a lesson, or type 0 to return to course menu.

 1: Basic Building Blocks      2: Workspace and Files        3: Sequences of Numbers    
 4: Vectors                    5: Missing Values             6: Subsetting Vectors      
 7: Matrices and Data Frames   8: Logic                      9: Functions               
10: lapply and sapply         11: vapply and tapply         12: Looking at Data         
13: Simulation                14: Dates and Times           15: Base Graphics           


Selection: 5

  |                                                                                                             |   0%

| Missing values play an important role in statistics and data analysis. Often, missing values must not be ignored,
| but rather they should be carefully studied to see if there's an underlying pattern or cause for their missingness.

...

  |=====                                                                                                        |   5%
| In R, NA is used to represent any value that is 'not available' or 'missing' (in the statistical sense). In this
| lesson, we'll explore missing values further.

...

  |===========                                                                                                  |  10%
| Any operation involving NA generally yields NA as the result. To illustrate, let's create a vector c(44, NA, 5, NA)
| and assign it to a variable x.

> x <- c(44, NA, 5, NA)

| You are quite good my friend!

  |================                                                                                             |  15%
| Now, let's multiply x by 3.

> x*3
[1] 132  NA  15  NA

| Excellent work!

  |======================                                                                                       |  20%
| Notice that the elements of the resulting vector that correspond with the NA values in x are also NA.

...

  |===========================                                                                                  |  25%
| To make things a little more interesting, lets create a vector containing 1000 draws from a standard normal
| distribution with y <- rnorm(1000).

> y <- rnorm(1000)

| All that hard work is paying off!

  |=================================                                                                            |  30%
| Next, let's create a vector containing 1000 NAs with z <- rep(NA, 1000).

> z <- rep(NA, 1000)

| You nailed it! Good job!

  |======================================                                                                       |  35%
| Finally, let's select 100 elements at random from these 2000 values (combining y and z) such that we don't know how
| many NAs we'll wind up with or what positions they'll occupy in our final vector -- my_data <- sample(c(y, z), 100).

> my_data <- sample(c(y, z), 100)

| Perseverance, that's the answer.

  |============================================                                                                 |  40%
| Let's first ask the question of where our NAs are located in our data. The is.na() function tells us whether each
| element of a vector is NA. Call is.na() on my_data and assign the result to my_na.

> is.na(my_data)
  [1] FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE  TRUE
 [20]  TRUE  TRUE FALSE  TRUE FALSE FALSE  TRUE FALSE  TRUE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE
 [39]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE
 [58] FALSE  TRUE FALSE  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE
 [77] FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE
 [96]  TRUE FALSE FALSE  TRUE  TRUE

| Not quite right, but keep trying. Or, type info() for more options.

| Assign the result of is.na(my_data) to the variable my_na.

> my_na <- is.na(my_data)

| All that hard work is paying off!

  |=================================================                                                            |  45%
| Now, print my_na to see what you came up with.

> my_na
  [1] FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE  TRUE
 [20]  TRUE  TRUE FALSE  TRUE FALSE FALSE  TRUE FALSE  TRUE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE
 [39]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE
 [58] FALSE  TRUE FALSE  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE
 [77] FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE
 [96]  TRUE FALSE FALSE  TRUE  TRUE

| All that practice is paying off!

  |======================================================                                                       |  50%
| Everywhere you see a TRUE, you know the corresponding element of my_data is NA. Likewise, everywhere you see a
| FALSE, you know the corresponding element of my_data is one of our random draws from the standard normal
| distribution.

...

  |============================================================                                                 |  55%
| In our previous discussion of logical operators, we introduced the `==` operator as a method of testing for equality
| between two objects. So, you might think the expression my_data == NA yields the same results as is.na(). Give it a
| try.

> my_data == NA yields
Error: unexpected symbol in "my_data == NA yields"
> my_data == NA yields == is.na(my_data)
Error: unexpected symbol in "my_data == NA yields"
> my_data == NA yields = is.na(my_data)
Error: unexpected symbol in "my_data == NA yields"
> (my_data == NA yields) = is.na(my_data)
Error: unexpected symbol in "(my_data == NA yields"
> (my_data == NA yields) == is.na(my_data)
Error: unexpected symbol in "(my_data == NA yields"
> (my_data == NA yields)
Error: unexpected symbol in "(my_data == NA yields"
> my_data `==` NA yields
Error: unexpected symbol in "my_data `==`"
> (my_data == NA yields) `==` is.na(my_data)
Error: unexpected symbol in "(my_data == NA yields"
> is.na(my_data)
  [1] FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE  TRUE
 [20]  TRUE  TRUE FALSE  TRUE FALSE FALSE  TRUE FALSE  TRUE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE
 [39]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE
 [58] FALSE  TRUE FALSE  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE
 [77] FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE
 [96]  TRUE FALSE FALSE  TRUE  TRUE

| Not quite! Try again. Or, type info() for more options.

| Try my_data == NA to see what happens.

> my_data == NA
  [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA
 [39] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA
 [77] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA

| That's a job well done!

  |=================================================================                                            |  60%
| The reason you got a vector of all NAs is that NA is not really a value, but just a placeholder for a quantity that
| is not available. Therefore the logical expression is incomplete and R has no choice but to return a vector of the
| same length as my_data that contains all NAs.

...

  |=======================================================================                                      |  65%
| Don't worry if that's a little confusing. The key takeaway is to be cautious when using logical expressions anytime
| NAs might creep in, since a single NA value can derail the entire thing.

...

  |============================================================================                                 |  70%
| So, back to the task at hand. Now that we have a vector, my_na, that has a TRUE for every NA and FALSE for every
| numeric value, we can compute the total number of NAs in our data.

...

  |==================================================================================                           |  75%
| The trick is to recognize that underneath the surface, R represents TRUE as the number 1 and FALSE as the number 0.
| Therefore, if we take the sum of a bunch of TRUEs and FALSEs, we get the total number of TRUEs.

...

  |=======================================================================================                      |  80%
| Let's give that a try here. Call the sum() function on my_na to count the total number of TRUEs in my_na, and thus
| the total number of NAs in my_data. Don't assign the result to a new variable.

> sum(my_na) 
[1] 47

| You are quite good my friend!

  |=============================================================================================                |  85%
| Pretty cool, huh? Finally, let's take a look at the data to convince ourselves that everything 'adds up'. Print
| my_data to the console.

> my_data
  [1] -1.102496109 -0.618440258           NA  0.716179125  0.625902401           NA           NA -0.492568686
  [9] -1.424234060 -0.217734481           NA           NA           NA           NA -0.160788831           NA
 [17]  0.225247583           NA           NA           NA           NA  0.678988973           NA -0.114941035
 [25]  0.725488516           NA  0.378705284           NA           NA -3.206925582           NA -1.956790241
 [33]           NA  0.979826836  0.218772186           NA           NA -1.218586668           NA           NA
 [41]  1.306903153 -1.273946802  0.210160649 -0.527960247 -1.905586902  0.014322234  1.053162992  0.090874264
 [49] -3.020836100 -0.580584513           NA           NA           NA  0.484392542           NA           NA
 [57]           NA -1.537378649           NA -0.214830964           NA           NA -0.511990115           NA
 [65] -0.740707189  1.737762528  2.087333969           NA           NA  1.319852618  0.748968379 -0.221682137
 [73]           NA  0.958086303           NA -0.568148438  1.179232064           NA -0.816068114  0.577825651
 [81]  0.229654839  0.696556129           NA           NA -0.293787644  0.109886385 -1.303956301           NA
 [89]           NA -0.868004113  0.514766799  0.246075022           NA           NA           NA           NA
 [97] -0.321668689  0.008106917           NA           NA

| You got it right!

  |==================================================================================================           |  90%
| Now that we've got NAs down pat, let's look at a second type of missing value -- NaN, which stands for 'not a
| number'. To generate NaN, try dividing (using a forward slash) 0 by 0 now.

> 0/0
[1] NaN

| All that practice is paying off!

  |========================================================================================================     |  95%
| Let's do one more, just for fun. In R, Inf stands for infinity. What happens if you subtract Inf from Inf?

> inf-inf
Error: object 'inf' not found
> Inf - Inf
[1] NaN

| Nice work!

  |=============================================================================================================| 100%
| Would you like to inform someone about your successful completion of this lesson via email?

1: Yes
2: No

Selection: 2

| You are quite good my friend!

| You've reached the end of this lesson! Returning to the main menu...

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: R Programming E
3: Take me to the swirl course repository!

Selection: 2

| Please choose a lesson, or type 0 to return to course menu.

 1: Basic Building Blocks      2: Workspace and Files        3: Sequences of Numbers    
 4: Vectors                    5: Missing Values             6: Subsetting Vectors      
 7: Matrices and Data Frames   8: Logic                      9: Functions               
10: lapply and sapply         11: vapply and tapply         12: Looking at Data         
13: Simulation                14: Dates and Times           15: Base Graphics           


Selection: save.image("~/FY2/FY2 Academic Block/JH R Programming Course/JH R Programming Course SWIRL Module/JH R Programming Course SWIRL Module 2-4.R.RData")
Enter an item from the menu, or 0 to exit
Selection: 6

  |                                                                                                             |   0%

| In this lesson, we'll see how to extract elements from a vector based on some conditions that we specify.

...

  |===                                                                                                          |   3%
| For example, we may only be interested in the first 20 elements of a vector, or only the elements that are not NA,
| or only those that are positive or correspond to a specific variable of interest. By the end of this lesson, you'll
| know how to handle each of these scenarios.

...

  |======                                                                                                       |   5%
| I've created for you a vector called x that contains a random ordering of 20 numbers (from a standard normal
| distribution) and 20 NAs. Type x now to see what it looks like.

> x
 [1]          NA          NA          NA          NA          NA  0.33678392  1.06535617  0.17621865          NA
[10]          NA -0.96370366 -0.75006171 -0.09648514          NA          NA -0.41310524          NA          NA
[19]          NA  1.57752171          NA          NA -0.19386832  0.21221505  1.08228267 -0.19859655          NA
[28]  0.58339444 -0.59712583          NA  0.52399067  1.00806704          NA  0.21544417          NA -0.32520786
[37]          NA -1.23324769 -0.81667962          NA

| You are doing so well!

  |========                                                                                                     |   8%
| The way you tell R that you want to select some particular elements (i.e. a 'subset') from a vector is by placing an
| 'index vector' in square brackets immediately following the name of the vector.

...

  |===========                                                                                                  |  10%
| For a simple example, try x[1:10] to view the first ten elements of x.

> x[1:10]
 [1]        NA        NA        NA        NA        NA 0.3367839 1.0653562 0.1762187        NA        NA

| You nailed it! Good job!

  |==============                                                                                               |  13%
| Index vectors come in four different flavors -- logical vectors, vectors of positive integers, vectors of negative
| integers, and vectors of character strings -- each of which we'll cover in this lesson.

...

  |=================                                                                                            |  15%
| Let's start by indexing with logical vectors. One common scenario when working with real-world data is that we want
| to extract all elements of a vector that are not NA (i.e. missing data). Recall that is.na(x) yields a vector of
| logical values the same length as x, with TRUEs corresponding to NA values in x and FALSEs corresponding to non-NA
| values in x.

...

  |====================                                                                                         |  18%
| What do you think x[is.na(x)] will give you?

1: A vector of all NAs
2: A vector of length 0
3: A vector of TRUEs and FALSEs
4: A vector with no NAs

Selection: 3

| You're close...I can feel it! Try it again.

| Remember that is.na(x) tells us where the NAs are in a vector. So if we subset x based on that, what do you expect
| to happen?

1: A vector of length 0
2: A vector of TRUEs and FALSEs
3: A vector with no NAs
4: A vector of all NAs

Selection: 4

| That's a job well done!

  |======================                                                                                       |  21%
| Prove it to yourself by typing x[is.na(x)].

> x[is.na(x)]
 [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA

| Excellent job!

  |=========================                                                                                    |  23%
| Recall that `!` gives us the negation of a logical expression, so !is.na(x) can be read as 'is not NA'. Therefore,
| if we want to create a vector called y that contains all of the non-NA values from x, we can use y <- x[!is.na(x)].
| Give it a try.

> y <- x[!is.na(x)]

| Great job!

  |============================                                                                                 |  26%
| Print y to the console.

> y
 [1]  0.33678392  1.06535617  0.17621865 -0.96370366 -0.75006171 -0.09648514 -0.41310524  1.57752171 -0.19386832
[10]  0.21221505  1.08228267 -0.19859655  0.58339444 -0.59712583  0.52399067  1.00806704  0.21544417 -0.32520786
[19] -1.23324769 -0.81667962

| You are amazing!

  |===============================                                                                              |  28%
| Now that we've isolated the non-missing values of x and put them in y, we can subset y as we please.

...

  |==================================                                                                           |  31%
| Recall that the expression y > 0 will give us a vector of logical values the same length as y, with TRUEs
| corresponding to values of y that are greater than zero and FALSEs corresponding to values of y that are less than
| or equal to zero. What do you think y[y > 0] will give you?

1: A vector of all NAs
2: A vector of all the positive elements of y
3: A vector of TRUEs and FALSEs
4: A vector of all the negative elements of y
5: A vector of length 0

Selection: 2

| You're the best!

  |====================================                                                                         |  33%
| Type y[y > 0] to see that we get all of the positive elements of y, which are also the positive elements of our
| original vector x.

> y[y > 0]
 [1] 0.3367839 1.0653562 0.1762187 1.5775217 0.2122150 1.0822827 0.5833944 0.5239907 1.0080670 0.2154442

| All that hard work is paying off!

  |=======================================                                                                      |  36%
| You might wonder why we didn't just start with x[x > 0] to isolate the positive elements of x. Try that now to see
| why.

> x[x > 0]
 [1]        NA        NA        NA        NA        NA 0.3367839 1.0653562 0.1762187        NA        NA        NA
[12]        NA        NA        NA        NA 1.5775217        NA        NA 0.2122150 1.0822827        NA 0.5833944
[23]        NA 0.5239907 1.0080670        NA 0.2154442        NA        NA        NA

| Your dedication is inspiring!

  |==========================================                                                                   |  38%
| Since NA is not a value, but rather a placeholder for an unknown quantity, the expression NA > 0 evaluates to NA.
| Hence we get a bunch of NAs mixed in with our positive numbers when we do this.

...

  |=============================================                                                                |  41%
| Combining our knowledge of logical operators with our new knowledge of subsetting, we could do this -- x[!is.na(x) &
| x > 0]. Try it out.

> x[!is.na(x)
+ | x > 0]
 [1]          NA          NA          NA          NA          NA  0.33678392  1.06535617  0.17621865          NA
[10]          NA -0.96370366 -0.75006171 -0.09648514          NA          NA -0.41310524          NA          NA
[19]          NA  1.57752171          NA          NA -0.19386832  0.21221505  1.08228267 -0.19859655          NA
[28]  0.58339444 -0.59712583          NA  0.52399067  1.00806704          NA  0.21544417          NA -0.32520786
[37]          NA -1.23324769 -0.81667962          NA

| That's not the answer I was looking for, but try again. Or, type info() for more options.

| Try x[!is.na(x) & x > 0] to see what you get.

> x[!is.na(x) & x > 0]
 [1] 0.3367839 1.0653562 0.1762187 1.5775217 0.2122150 1.0822827 0.5833944 0.5239907 1.0080670 0.2154442

| Excellent job!

  |================================================                                                             |  44%
| In this case, we request only values of x that are both non-missing AND greater than zero.

...

  |==================================================                                                           |  46%
| I've already shown you how to subset just the first ten values of x using x[1:10]. In this case, we're providing a
| vector of positive integers inside of the square brackets, which tells R to return only the elements of x numbered 1
| through 10.

...

  |=====================================================                                                        |  49%
| Many programming languages use what's called 'zero-based indexing', which means that the first element of a vector
| is considered element 0. R uses 'one-based indexing', which (you guessed it!) means the first element of a vector is
| considered element 1.

...

  |========================================================                                                     |  51%
| Can you figure out how we'd subset the 3rd, 5th, and 7th elements of x? Hint -- Use the c() function to specify the
| element numbers as a numeric vector.

> c((x 1,2,3))
Error: unexpected numeric constant in "c((x 1"
> c(x[1:10])
 [1]        NA        NA        NA        NA        NA 0.3367839 1.0653562 0.1762187        NA        NA

| Try again. Getting it right on the first try is boring anyway! Or, type info() for more options.

| Create a vector of indexes with c(3, 5, 7), then put that inside of the square brackets.

> x[c(3, 5, 7)]
[1]       NA       NA 1.065356

| That's correct!

  |===========================================================                                                  |  54%
| It's important that when using integer vectors to subset our vector x, we stick with the set of indexes {1, 2, ...,
| 40} since x only has 40 elements. What happens if we ask for the zeroth element of x (i.e. x[0])? Give it a try.

> x[0]
numeric(0)

| Keep up the great work!

  |=============================================================                                                |  56%
| As you might expect, we get nothing useful. Unfortunately, R doesn't prevent us from doing this. What if we ask for
| the 3000th element of x? Try it out.

> x[3000]
[1] NA

| Excellent work!

  |================================================================                                             |  59%
| Again, nothing useful, but R doesn't prevent us from asking for it. This should be a cautionary tale. You should
| always make sure that what you are asking for is within the bounds of the vector you're working with.

...

  |===================================================================                                          |  62%
| What if we're interested in all elements of x EXCEPT the 2nd and 10th? It would be pretty tedious to construct a
| vector containing all numbers 1 through 40 EXCEPT 2 and 10.

...

  |======================================================================                                       |  64%
| Luckily, R accepts negative integer indexes. Whereas x[c(2, 10)] gives us ONLY the 2nd and 10th elements of x,
| x[c(-2, -10)] gives us all elements of x EXCEPT for the 2nd and 10 elements.  Try x[c(-2, -10)] now to see this.

> x[c(-2, -10)]
 [1]          NA          NA          NA          NA  0.33678392  1.06535617  0.17621865          NA -0.96370366
[10] -0.75006171 -0.09648514          NA          NA -0.41310524          NA          NA          NA  1.57752171
[19]          NA          NA -0.19386832  0.21221505  1.08228267 -0.19859655          NA  0.58339444 -0.59712583
[28]          NA  0.52399067  1.00806704          NA  0.21544417          NA -0.32520786          NA -1.23324769
[37] -0.81667962          NA

| You're the best!

  |=========================================================================                                    |  67%
| A shorthand way of specifying multiple negative numbers is to put the negative sign out in front of the vector of
| positive numbers. Type x[-c(2, 10)] to get the exact same result.

> x[-c(2, 10)]
 [1]          NA          NA          NA          NA  0.33678392  1.06535617  0.17621865          NA -0.96370366
[10] -0.75006171 -0.09648514          NA          NA -0.41310524          NA          NA          NA  1.57752171
[19]          NA          NA -0.19386832  0.21221505  1.08228267 -0.19859655          NA  0.58339444 -0.59712583
[28]          NA  0.52399067  1.00806704          NA  0.21544417          NA -0.32520786          NA -1.23324769
[37] -0.81667962          NA

| Great job!

  |===========================================================================                                  |  69%
| So far, we've covered three types of index vectors -- logical, positive integer, and negative integer. The only
| remaining type requires us to introduce the concept of 'named' elements.

...

  |==============================================================================                               |  72%
| Create a numeric vector with three named elements using vect <- c(foo = 11, bar = 2, norf = NA).

> vect <- c(foo = 11, bar = 2, norf = NA)

| Excellent job!

  |=================================================================================                            |  74%
| When we print vect to the console, you'll see that each element has a name. Try it out.

> vect
 foo  bar norf 
  11    2   NA 

| Your dedication is inspiring!

  |====================================================================================                         |  77%
| We can also get the names of vect by passing vect as an argument to the names() function. Give that a try.

> names(names)
NULL

| Try again. Getting it right on the first try is boring anyway! Or, type info() for more options.

| Check out the results of names(vect).

> names(vect)
[1] "foo"  "bar"  "norf"

| Excellent job!

  |=======================================================================================                      |  79%
| Alternatively, we can create an unnamed vector vect2 with c(11, 2, NA). Do that now.

> vect2 <- c(11, 2, NA)

| Great job!

  |=========================================================================================                    |  82%
| Then, we can add the `names` attribute to vect2 after the fact with names(vect2) <- c("foo", "bar", "norf"). Go
| ahead.

> names(vect2) <- c("foo", "bar", "norf")

| You are doing so well!

  |============================================================================================                 |  85%
| Now, let's check that vect and vect2 are the same by passing them as arguments to the identical() function.

> identical(vect, vect2)
[1] TRUE

| That's a job well done!

  |===============================================================================================              |  87%
| Indeed, vect and vect2 are identical named vectors.

...

  |==================================================================================================           |  90%
| Now, back to the matter of subsetting a vector by named elements. Which of the following commands do you think would
| give us the second element of vect?

1: vect["bar"]
2: vect[bar]
3: vect["2"]

Selection: 3

| That's not exactly what I'm looking for. Try again.

| If we want the element named "bar" (i.e. the second element of vect), which command would get us that?

1: vect["bar"]
2: vect["2"]
3: vect[bar]

Selection: 1

| You are amazing!

  |=====================================================================================================        |  92%
| Now, try it out.

> vect["bar"]
bar 
  2 

| You are amazing!

  |=======================================================================================================      |  95%
| Likewise, we can specify a vector of names with vect[c("foo", "bar")]. Try it out.

> vect[c("foo", "bar")]
foo bar 
 11   2 

| All that practice is paying off!

  |==========================================================================================================   |  97%
| Now you know all four methods of subsetting data from vectors. Different approaches are best in different scenarios
| and when in doubt, try it out!
